# NavigationService 使用指南

本文档介绍如何在项目中初始化与使用 `NavigationService`，包括路由注册、页面导航、前进/后退以及在 ViewModel 中接入导航事件以驱动主内容区切换。

## 初始化与依赖注入

项目使用 `Microsoft.Extensions.DependencyInjection` 进行依赖注入。在 `Program.cs` 中已经注册了导航服务与相关 ViewModel：

```csharp
// Program.cs
services.AddSingleton<INavigationService, NavigationService>();
services.AddTransient<MainWindowViewModel>();
services.AddTransient<StatusBarViewModel>();
services.AddTransient<LogManagementViewModel>();
```

在 `App.axaml.cs` 中于应用启动时完成路由配置：

```csharp
// App.axaml.cs
var navigationService = Program.ServiceProvider.GetRequiredService<INavigationService>();
RouteConfiguration.ConfigureRoutes(navigationService, Program.ServiceProvider);
```

路由配置集中在 `RouteConfiguration.ConfigureRoutes`：

```csharp
// RouteConfiguration.cs
navigationService.Register("LogManagement", () =>
{
    var vm = serviceProvider.GetRequiredService<LogManagementViewModel>();
    return new LogManagementView(vm);
}, title: "日志管理");
```

## 在 ViewModel 中使用导航

`MainWindowViewModel` 订阅导航事件以更新页面标题与主内容区：

```csharp
_navigationService.Navigating += (_, e) =>
{
    _logger.LogInformation("导航至 {Route}", e.RouteKey);
    _statusBarManager.Text = $"正在导航: {e.Title ?? e.RouteKey}";
};
_navigationService.Navigated += (_, e) =>
{
    ContentTitle = e.Title ?? e.RouteKey;
    CurrentContent = e.Content; // 绑定到 MainContentArea.ContentPresenter
    _statusBarManager.Text = $"已导航: {ContentTitle}";
};
```

当导航树选中某项时发起导航：

```csharp
switch (navigationItem.Id)
{
    case "LogManagement":
        _navigationService.Navigate("LogManagement", mode: NavigationMode.Replace);
        break;
}
```

## XAML 主内容区绑定

主内容区通过 `ContentPresenter` 绑定 `CurrentContent`：

```xml
<!-- MainContentArea.axaml -->
<ContentPresenter Content="{Binding CurrentContent}" />
```

## API 参考

- INavigationService.Register(string routeKey, Func<object> contentFactory, string? title = null)
  - 注册路由与页面工厂。`routeKey` 唯一，`contentFactory` 返回一个 View 实例。

- INavigationService.Navigate(string routeKey, object? parameter = null, NavigationMode mode = NavigationMode.Push)
  - 导航到指定路由。
  - mode = Push：将当前页压入后退栈；mode = Replace：替换当前页不入栈。

- INavigationService.CanGoBack / CanGoForward
  - 是否可后退/前进。

- INavigationService.GoBack() / GoForward()
  - 触发后退/前进导航。

- 事件：Navigating / Navigated
  - Navigating：即将导航；Navigated：完成导航。
  - 事件会在 UI 线程上被触发，可直接更新绑定属性。

## 代码示例（最小可用）

```csharp
// 注册（启动时）
navigationService.Register("Home", () => new HomeView(), title: "首页");
navigationService.Register("Settings", () => new SettingsView(), title: "设置");

// 订阅（在 MainWindowViewModel 构造函数）
_navigationService.Navigated += (_, e) =>
{
    ContentTitle = e.Title ?? e.RouteKey;
    CurrentContent = e.Content;
};

// 执行导航
_navigationService.Navigate("Home");      // 首次进入
_navigationService.Navigate("Settings");  // 进入设置
if (_navigationService.CanGoBack)
{
    _navigationService.GoBack();          // 返回首页
}
```

## 常见问题

- 为什么 `title` 参数在实现中未存储？
  - 当前实现将标题的最终展示权交给外层 ViewModel，内部仅用 `routeKey` 作为默认标题。参数保留用于未来扩展（例如集中式标题表）。

- 如何传递参数到页面？
  - 现有 `Navigate` 的 `parameter` 暂未在内部传递。推荐通过以下途径：
    - 使用 DI 从容器解析所需服务/状态。
    - 在 `contentFactory` 闭包中捕获参数或使用共享状态服务。

- 是否支持对话框区域导航或生命周期钩子（OnLeaving）？
  - 尚未实现。可在后续版本扩展：定义 `INavigable` 接口并在 `Navigate/GoBack/GoForward` 适时调用。
