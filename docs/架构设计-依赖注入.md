# 依赖注入架构设计说明

## 🎯 设计原则

### 为什么将服务注册放在 Program.cs 而不是 App.axaml.cs？

## 📋 对比分析

### ❌ 之前的设计（分散配置）

```csharp
// Program.cs - 只负责日志配置
Log.Logger = LoggingConfiguration.ConfigureSerilog();

// App.axaml.cs - 负责服务注册
private void ConfigureServices()
{
    var services = new ServiceCollection();
    services.AddLogging(builder => builder.AddSerilog());
    services.AddSingleton<ILoggerService, LoggerService>();
    _serviceProvider = services.BuildServiceProvider();
}
```

**问题：**
- 职责分散：配置分布在两个文件中
- 依赖混乱：日志配置在 Program.cs，服务注册在 App.axaml.cs
- 不易维护：修改服务配置需要在多个地方改动

### ✅ 当前设计（集中配置）

```csharp
// Program.cs - 统一负责所有配置
public static void Main(string[] args)
{
    // 1. 配置日志
    Log.Logger = LoggingConfiguration.ConfigureSerilog();
    
    // 2. 设置异常处理
    SetupGlobalExceptionHandling();
    
    // 3. 配置依赖注入
    ConfigureServices();
    
    // 4. 启动应用程序
    BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
}

// App.axaml.cs - 只负责 UI 初始化
public override void OnFrameworkInitializationCompleted()
{
    var mainWindowViewModel = Program.ServiceProvider.GetService<MainWindowViewModel>();
    desktop.MainWindow = new MainWindow { DataContext = mainWindowViewModel };
}
```

## 🏗️ 架构优势

### 1. **单一职责原则**
- `Program.cs`: 应用程序启动和基础设施配置
- `App.axaml.cs`: UI 框架初始化和窗口创建

### 2. **依赖关系清晰**
```
Program.cs (启动层)
├── 日志配置
├── 异常处理配置  
├── 依赖注入配置
└── 应用程序启动
    └── App.axaml.cs (UI层)
        └── 窗口和 ViewModel 初始化
```

### 3. **配置集中化**
- 所有基础设施配置都在 `Program.cs` 中
- 便于统一管理和修改
- 启动顺序明确

### 4. **生命周期管理**
```csharp
try
{
    // 应用程序运行
}
finally
{
    // 统一清理资源
    ServiceProvider?.Dispose();
    Log.CloseAndFlush();
}
```

## 🔄 与其他框架的对比

### ASP.NET Core 风格
```csharp
// Program.cs
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddLogging();
builder.Services.AddSingleton<IMyService, MyService>();
var app = builder.Build();
app.Run();
```

### 我们的 Avalonia 风格
```csharp
// Program.cs
Log.Logger = LoggingConfiguration.ConfigureSerilog();
ConfigureServices(); // 配置所有服务
BuildAvaloniaApp().StartWithClassicDesktopLifetime(args);
```

## 📊 日志输出对比

### 重构前的日志
```log
[22:24:37 INF] 应用程序启动 {}
[22:24:37 INF] MainWindowViewModel 初始化开始 {}
```

### 重构后的日志
```log
[22:27:21 INF] 依赖注入服务配置完成 {}
[22:27:21 INF] 应用程序启动 {}
[22:27:21 INF] MainWindowViewModel 初始化开始 {}
```

**改进：**
- 可以清楚看到配置阶段的完成
- 启动流程更加清晰
- 便于调试和监控

## 🎨 最佳实践

### 1. **服务注册顺序**
```csharp
private static void ConfigureServices()
{
    var services = new ServiceCollection();
    
    // 1. 基础服务（日志等）
    services.AddLogging(builder => builder.AddSerilog());
    
    // 2. 业务服务
    services.AddSingleton<ILoggerService, LoggerService>();
    
    // 3. UI 服务（ViewModels 等）
    services.AddTransient<MainWindowViewModel>();
    
    ServiceProvider = services.BuildServiceProvider();
}
```

### 2. **服务生命周期选择**
- **Singleton**: 全局唯一实例（如日志服务）
- **Transient**: 每次请求新实例（如 ViewModels）
- **Scoped**: 在特定作用域内单例（Web 应用常用，桌面应用较少）

### 3. **资源清理**
```csharp
finally
{
    Log.Information("应用程序关闭");
    ServiceProvider?.Dispose(); // 清理依赖注入容器
    Log.CloseAndFlush();        // 刷新并关闭日志
}
```

## 🚀 扩展建议

### 1. **配置文件支持**
```csharp
// 未来可以添加
services.Configure<AppSettings>(configuration.GetSection("AppSettings"));
```

### 2. **环境区分**
```csharp
// 根据环境配置不同的服务
if (Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") == "Development")
{
    services.AddTransient<IDataService, MockDataService>();
}
else
{
    services.AddTransient<IDataService, RealDataService>();
}
```

### 3. **服务健康检查**
```csharp
// 启动时验证关键服务
var logger = ServiceProvider.GetRequiredService<ILoggerService>();
logger.LogInformation("所有服务注册成功");
```

---

这种设计让我们的应用程序具有清晰的架构层次，便于维护和扩展！
